use scoped_arena::Scope;

use pion_source::location::{BytePos, ByteRange};
use crate::tokens::Token;
use crate::syntax::*;
use crate::reporting::{TokenError, SyntaxError};

grammar<'arena, 'source>(
    builder: Builder<'arena>,
    scope: &'arena Scope<'arena>,
    errors: &mut Vec<SyntaxError>,
);

extern {
    type Location = BytePos;
    type Error = TokenError;

    enum Token<'source> {
        "Ident" => Token::Ident(<&'source str>),
        "Hole" => Token::Hole(<&'source str>),
        "DecInt" => Token::DecInt(<&'source str>),
        "BinInt" => Token::BinInt(<&'source str>),
        "HexInt" => Token::HexInt(<&'source str>),

        "def" => Token::KwDef,
        "else" => Token::KwElse,
        "false" => Token::KwFalse,
        "fun" => Token::KwFun,
        "if" => Token::KwIf,
        "let" => Token::KwLet,
        "match" => Token::KwMatch,
        "then" => Token::KwThen,
        "true" => Token::KwTrue,

        "_" => Token::Underscore,
        "->" => Token::ThinArrow,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "." => Token::Dot,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LCurly,
        "}" => Token::RCurly,
        "@" => Token::At,
        "=" => Token::Eq,
        "=>" => Token::FatArrow,
    }
}

pub Def: Def<'arena> = {
    <start: @L> "def" <name: Ident> <r#type: Ann?> "=" <expr: Expr> ";" <end: @R> => builder.def((start, end), name, r#type, expr),
}

pub Expr: Expr<'arena> = {
    // <start: @L> <expr: AtomExpr> ":" <r#type: FunExpr> <end: @R> => builder.ann((start, end), expr, r#type),
    LetExpr => <>,
}

LetExpr: Expr<'arena> = {
    IfExpr => <>,
    FunExpr => <>,
}

IfExpr: Expr<'arena> = {
    <start: @L> "if" <cond: LetExpr> "then" <then: Block> "else" <r#else: Block> <end: @R> => builder.if_then_else((start, end), cond, then, r#else),
}

LetDef: LetDef<'arena> = {
    <pat: Pat> <r#type: Ann?> "=" <expr: Expr> => LetDef {pat, r#type, expr},
}

FunExpr: Expr<'arena> = {
    <start: @L> <arg: AppExpr> "->" <body: FunExpr> <end: @R> => builder.arrow((start, end), Plicity::Explicit, arg, body),
    <start: @L> "fun" <params: Param+> "->" <body: FunExpr> <end: @R> => builder.fun_type((start, end), scope.to_scope_from_iter(params), body),
    <start: @L> "fun" <params: Param+> "=>" <body: LetExpr> <end: @R> => builder.fun_lit((start, end), scope.to_scope_from_iter(params), body),
    AppExpr => <>,
}

AppExpr: Expr<'arena> = {
    <start: @L> <fun: AppExpr> "(" <args: Seq<Arg, ",">> ")" <end: @R> => builder.fun_app((start, end), fun, args),
    ProjExpr => <>,
}

ProjExpr: Expr<'arena> = {
    <start: @L> <head: AtomExpr> <labels: ("." <RangeIdent>)+> <end: @R> => builder.record_proj((start, end), head, scope.to_scope_from_iter(labels)),
    AtomExpr => <>,
}

AtomExpr: Expr<'arena> = {
    <start: @L> "(" <expr: Expr> ")" <end: @R> => builder.paren((start, end), expr),
    <start: @L> <exprs: Tuple<Expr>> <end: @R> => Expr::TupleLit(ByteRange::new(start, end), exprs),
    <start: @L> <lit: Lit> <end: @R> => Expr::Lit(ByteRange::new(start, end), lit),
    <start: @L> "_" <end: @R> => Expr::Placeholder(ByteRange::new(start, end)),
    <start: @L> <hole: Hole> <end: @R> => Expr::Hole(ByteRange::new(start, end), hole),
    <start: @L> <ident: Ident> <end: @R> => Expr::Ident(ByteRange::new(start, end), ident),
    <start: @L> "{" <fields: Seq1<TypeField, ",">> "}" <end: @R> => Expr::RecordType(ByteRange::new(start, end), fields),
    <start: @L> "{" <fields: Seq1<ExprField, ",">> "}" <end: @R> => Expr::RecordLit(ByteRange::new(start, end), fields),
    MatchExpr => <>,
    BlockExpr => <>,
}

BlockExpr: Expr<'arena> = {
    <start: @L> <block: Block> <end: @R> => Expr::Block(ByteRange::new(start, end), block),
}

Block: Block<'arena> = {
    "{" <stmts: Stmt*> <expr: Expr?> "}" => Block {stmts: scope.to_scope_from_iter(stmts), expr: expr.map(|expr| scope.to_scope(expr) as &_)},
}

Stmt: Stmt<'arena> = {
    "let" <def: LetDef> ";" => Stmt::Let(def),
    <expr: Expr> ";" => Stmt::Expr(expr),
}

MatchExpr: Expr<'arena> = {
    <start: @L> "match" <scrut: ProjExpr> "{" <cases: Seq<MatchCase, ",">> "}" <end: @R> => Expr::Match(ByteRange::new(start, end), scope.to_scope(scrut), cases),
}

TypeField: TypeField<'arena> = {
    <label: RangeIdent> ":" <r#type: Expr> => TypeField {label, r#type},
}

ExprField: ExprField<'arena> = {
    <label: RangeIdent> "=" <expr: Expr> => ExprField {label, expr},
}

PatField: PatField<'arena> = {
    <label: RangeIdent> "=" <pat: Pat> => PatField {label, pat},
}

MatchCase: MatchCase<'arena> = {
    <pat: Pat> "=>" <expr: Expr> => MatchCase {pat, expr},
}

Param: Param<'arena> = {
    <plicity: Plicity> <pat: Pat> => Param {plicity, pat, r#type: None},
    "("<plicity: Plicity> <pat: Pat> <r#type: Ann> ")" => Param {plicity, pat, r#type: Some(r#type)},
}

Arg: Arg<'arena> = {
    <start: @L> <plicity: Plicity> <expr: Expr> <end: @R> => Arg {extra: ByteRange::new(start, end), plicity, expr},
}

#[inline]
Plicity: Plicity = {
    () =>  Plicity::Explicit,
    "@" => Plicity::Implicit,
}

pub Pat: Pat<'arena> = {
    <start: @L> "(" <pat: Pat> ")" <end: @R> => Pat::Paren(ByteRange::new(start, end), scope.to_scope(pat)),
    <start: @L> <lit: Lit> <end: @R> => Pat::Lit(ByteRange::new(start, end), lit),
    <start: @L> <ident: Ident> <end: @R> => Pat::Ident(ByteRange::new(start, end), ident),
    <start: @L> "_" <end: @R> => Pat::Underscore(ByteRange::new(start, end)),
    <start: @L> <pats: Tuple<Pat>> <end: @R> => Pat::TupleLit(ByteRange::new(start, end), pats),
    <start: @L> "{" <fields: Seq<PatField, ",">> "}" <end: @R> => Pat::RecordLit(ByteRange::new(start, end), fields),
}

pub Lit: Lit = {
    <start: @L> "true" <end: @R> => Lit::Bool(ByteRange::new(start, end), true),
    <start: @L> "false" <end: @R> => Lit::Bool(ByteRange::new(start, end), false),
    <start: @L> <int: Int> <end: @R> => Lit::Int(ByteRange::new(start, end), int),
}

Int: u32 = {
    <start: @L> <str: "DecInt"> <end: @R> => match parse_decimal_integer(str) {
        Ok(int) => int,
        Err(err) => {
            errors.push(SyntaxError::IntLit(ByteRange::new(start, end), err));
            0
        }
    },
    <start: @L> <str: "BinInt"> <end: @R> => match parse_binary_integer(str) {
        Ok(int) => int,
        Err(err) => {
            errors.push(SyntaxError::IntLit(ByteRange::new(start, end), err));
            0
        }
    },
    <start: @L> <str: "HexInt"> <end: @R> => match parse_hexadecimal_integer(str) {
        Ok(int) => int,
        Err(err) => {
            errors.push(SyntaxError::IntLit(ByteRange::new(start, end), err));
            0
        }
    },
}

Tuple<Elem>: &'arena [Elem] = {
    "(" ")" => &[],
    "(" <elem: Elem> "," ")" => scope.to_scope_from_iter([elem]),
    "(" <elems: Seq2<Elem, ",">> ")" => elems,
};

Ann: Expr<'arena> = {
    ":" <expr: LetExpr> => expr,
}

Ident: Symbol = {
    <ident: "Ident"> => ident.into(),
}

#[inline]
RangeIdent: (ByteRange, Symbol) = {
    <start: @L> <ident: "Ident"> <end: @R> => (ByteRange::new(start, end), ident.into()),
}

Hole: Symbol = {
    <hole: "Hole"> => hole.into(),
}

Seq<Elem, Sep>: &'arena [Elem] = {
    <elems: (<Elem> Sep)*> <last: Elem?> => {
        scope.to_scope_from_iter(elems.into_iter().chain(last))
    }
};

Seq1<Elem, Sep>: &'arena [Elem] = {
    <first: Elem> <elems: (Sep <Elem>)*> Sep? => {
        scope.to_scope_from_iter(std::iter::once(first).chain(elems))
    },
};

Seq2<Elem, Sep>: &'arena [Elem] = {
    <first: Elem> Sep <second: Elem> <elems: (Sep <Elem>)*> Sep? => {
        scope.to_scope_from_iter(std::iter::once(first).chain(std::iter::once(second)).chain(elems))
    },
};
